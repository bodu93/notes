##### Templates in CPP

* 函数模板不能进行偏特化
* Two phase name lookup(两阶段名称查找)，即名称查找会在模板定义和实例化时各做一次，分别处理非依赖性名称和依赖性名称(即依赖模板参数)
* Name Lookup: 模板名字绑定的普遍问题是模板实例化涉及到3个上下文
  1. 模板定义的上下文
  2. 实参类型声明的上下文
  3. 模板使用的上下文
* C++将模板定义中使用的名字分为以下两类
  1. 依赖性名字:  依赖于模板参数的名字。这类名字在实例化点完成绑定
     * 特别的，我们称一个函数调用依赖一个模板参数(主要是由于函数重载的存在)当且仅当满足下列条件
       1. 函数实参类型依赖于一个模板参数T
       2. 函数有一个参数依赖于T
     * 默认情况下，编译器假定依赖性名字不是类型名。因此，为了使依赖性名字可以是一个类型，必须使用`typename`显示说明
     * 类似(`typename`)的，命名`.`(点)、`->`或`::`后面的成员模板需要使用关键字`template`
  2. 非依赖性名字: 不依赖于模板参数的名字。这类名字在模板的定义点完成绑定
* 将非依赖性名字变成依赖性名字的三种方法
  * 用依赖性类型(such as `T::g`)限定名字
  * 声明一个名字指向此类的一个对象(such as `this->g`)
  * 用`using`声明将名字引入作用域(such as `using T::g`)